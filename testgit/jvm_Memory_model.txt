1.
    所有的线程共享JVM内存区域main memory，而每个线程又单独的有自己的工作内存，当线程与内存区域进行交互时，数据从主存拷贝到工作内存，
进而交由线程处理（操作码+操作数）。

2.程序计数器
    程序计数器（Program Counter Register）是一块较小的内存空间，它是当前线程所执行的字节码的行号指示器。虚拟机的字节码解释器工作时就
是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。
因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，我们称这类内存区域为“线程私有”的内存。
    如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法
（java只提供无实现方法，实现由非java写），这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。

3.java栈
    Java 虚拟机栈（Java Virtual Machine Stacks）是线程私有的，它的生命周期与线程相同。每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、
操作栈、方法出口等信息。每一个方法被调用至完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
    局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress 类型（指向了一条字节码指令的地址）。
其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个
方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

4.java堆
    Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。几乎所有的对象实例都在这里分配内存。Java 堆是垃圾收集器管理的主要区域。
如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；
再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区。
进一步划分的目的是为了更好地回收内存，或者更快地分配内存。
    Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。
	
5.方法区
    方法区（Method Area），是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意。

6.运行时常量池
    运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool
Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    一个重要特征是具备动态性，运行期间也可能将新的常量放入池中。
	
7.Object obj = new Object();
    假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈
的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义
将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值。另外，在Java 堆中
还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地
址信息，这些类型数据则存储在方法区中。主流的访问方式有两种：使用句柄和直接指针。
    如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference
中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。
    这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference 中存 
储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只
会改变句柄中的实例数据指针，而reference 本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开
销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

8.垃圾回收算法
 1）标记-清除算法：从根节点开始标记所有可达对象，其余没标记的即为垃圾对象，执行清除。但回收后的空间是不连续的。
 2）复制算法：将内存分成两块，每次只使用其中一块，垃圾回收时，将标记的对象拷贝到另外一块中，然后完全清除原来使用的那块内存。
              复制后的空间是连续的。复制算法适用于新生代，因为垃圾对象多于存活对象，复制算法更高效。
 3）标记-压缩算法：适合用于老年代的算法（存活对象多于垃圾对象）。标记后不复制，而是将存活对象压缩到内存的一端，然后清理边界外的所有对象。






