1.数据库事物ACID：
   原子性：保证事务中的所有操作全部执行或全部不执行。
   一致性：保证数据库始终保持数据的一致性――事务操作之前是一致的，事务操作之后也是一致的，不管事务成功与否。
   隔离性：多个事务并发执行的话，结果应该与多个事务串行执行效果是一样的。
   持久性：持久性表示事物操作完成之后，对数据库的影响是持久的，即使数据库因故障而受到破坏，数据库也应该能够恢复。通常的实现方式是采用日志。

2.隔离级别
   串行化（SERIALIZABLE）：是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。
                           在事务完成之前，其他事务不能向事务已读取的范围插入新行的限制。比如，事务1读取了年龄在10到30之间的用户。
						   事务2在执行SQL statement产生一行或者多行满足事务1搜索条件的行时会冲突，则事务2回滚。
						   这时事务1再次读取了一系列满足相同搜索条件的行，第二次读取的结果和第一次读取的结果相同。（防止幻读）
						   
可重复读（REPEATABLE READ）：指定了在当前事务提交之前，其他任何事务均不可以修改或删除当前事务已读取的数据。
		                   并发性低于 READ COMMITTED，因为已读数据的共享锁在整个事务期间持有，而不是在每个语句结束时释放。
						   比如，事务1读取了一行，事务2想修改或者删除这一行并且提交，但是因为事务1尚未提交，数据行中有事务1的锁，
						   事务2无法进行更新操作，因此事务2阻塞。如果这时候事务1想再一次读取这一行，它读取结果与第一次读取结果相同，因此叫可重复读。
						   
 读已提交     READ COMMITTED：该级别通过指定语句不能读取其他事务已修改但是尚未提交的数据值，禁止执行脏读。在当前事务中的各个语句执行之间，
		                   其他事务仍可以修改、插入或删除数据，从而产生无法重复的读操作。比如，事务1读取了一行，事务2修改或者删除这一行并且提交。
						   如果事务1想再一次读取这一行，它将获得修改后的数据或者发现这一样已经被删除，因此事务的第二次读取结果与第一次读取结果不同，因此也叫不可重复读。
	     
读未提交    READ UNCOMMITTED：限制性最弱的隔离级别，因为该级别忽略其他事务放置的锁。可以读取尚未由其他事务提交的修改后的数据值，这些行为称为“脏”读。
		                   比如，事务1修改一行，事务2在事务1提交之前读取了这一行。如果事务1回滚，事务2就读取了一行没有提交的数据，这样的数据我们认为是不存在的。
						   

